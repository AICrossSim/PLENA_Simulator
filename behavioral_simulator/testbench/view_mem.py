from bitstring import BitArray
import torch
import os
import struct

def view_bin_file_by_row_int(bin_file,
                             row_dim,
                             int_width=32,
                             num_bytes_per_val=None,
                             start_row_idx=0,
                             load_row_size=None,
                             offset=0,
                             signed=True):
    """
    Reads a binary file and parses each value as an integer.

    - bin_file:         Path to the binary file
    - row_dim:          Number of values per row to group/print
    - int_width:        Bit width of the integer (default 32 for i32)
                        Common values: 8 (i8), 16 (i16), 32 (i32)
    - num_bytes_per_val:Number of bytes per value (auto-calculated from int_width if None)
    - start_row_idx:   Starting row index
    - load_row_size:    If set, limit number of rows to print
    - signed:           If True, interpret as signed integer (default True)

    Note: The Rust code uses little-endian byte order.
          If int_width is less than num_bytes_per_val * 8, the value will be masked.
    """
    # Auto-calculate bytes per value if not specified
    if num_bytes_per_val is None:
        num_bytes_per_val = (int_width + 7) // 8  # Round up to nearest byte

    # Validate that num_bytes_per_val is sufficient
    if int_width > num_bytes_per_val * 8:
        raise ValueError(f"int_width ({int_width}) exceeds num_bytes_per_val * 8 ({num_bytes_per_val * 8})")

    # Create mask for the specified bit width
    if int_width >= 64:
        mask = (1 << 64) - 1
    else:
        mask = (1 << int_width) - 1

    with open(bin_file, "rb") as f:
        data = f.read()
    num_vals = len(data) // num_bytes_per_val
    total_rows = (num_vals + row_dim - 1) // row_dim

    for row_idx in range(total_rows):
        if row_idx < start_row_idx:
            continue
        if load_row_size is not None and row_idx >= load_row_size + start_row_idx:
            print("... (truncated)")
            break
        vals = []
        for col_idx in range(row_dim):
            val_idx = row_idx * row_dim + col_idx + offset
            if val_idx >= num_vals:
                break
            chunk = data[val_idx * num_bytes_per_val : (val_idx + 1) * num_bytes_per_val]
            # print("chunk = {:?}", chunk)
            if not chunk or len(chunk) < num_bytes_per_val:
                vals.append(None)
                continue
            # Use little-endian byte order to match Rust's byte packing
            if signed:
                int_val = int.from_bytes(chunk, byteorder='little', signed=True)
            else:
                int_val = int.from_bytes(chunk, byteorder='little', signed=False)

            # Apply bit width mask
            int_val = int_val & mask

            # Sign extend if signed and the sign bit is set
            if signed and int_width < num_bytes_per_val * 8:
                sign_bit = (int_val >> (int_width - 1)) & 1
                if sign_bit == 1:
                    # Sign extend: set all upper bits to 1
                    sign_extend_mask = ((1 << (num_bytes_per_val * 8 - int_width)) - 1) << int_width
                    int_val = int_val | sign_extend_mask
                    # Convert to signed integer
                    if num_bytes_per_val == 1:
                        int_val = int_val if int_val < 128 else int_val - 256
                    elif num_bytes_per_val == 2:
                        int_val = int_val if int_val < 32768 else int_val - 65536
                    elif num_bytes_per_val == 4:
                        int_val = int_val if int_val < 2147483648 else int_val - 4294967296

            vals.append(int_val)
        print(f"Row {row_idx:3d}: ", end="")
        for v in vals:
            if v is not None:
                print(f"{v:8d}", end=" ")
            else:
                print("        ", end=" ")
        print()

def view_bin_file_by_row_fp(bin_file,
                         exp_width,
                         man_width,
                         row_dim,
                         num_bytes_per_val=2,
                         start_row_idx=0,
                         offset=0,
                         load_row_size=None):
    """
    Reads a binary file generated by Rust behavioral simulator, parses each value as custom FP.

    - bin_file:         Path to the binary file
    - exp_width:        Number of bits for exponent
    - man_width:        Number of bits for mantissa/fraction
    - row_dim:          Number of values per row to group/print
    - num_bytes_per_val:Number of bytes per value (default 2 for BF16)
    - start_row_idx:    Starting row index
    - load_row_size:    If set, limit number of rows to print

    Note: The Rust code uses bit-packing with little-endian byte order.
          For BF16 (16 bits), each value is aligned to 2 bytes.
    """
    sign_width = 1
    total_width = sign_width + exp_width + man_width
    if total_width > num_bytes_per_val * 8:
        raise ValueError("num_bytes_per_val is too small for given bit widths.")

    def raw_to_fp(bits_val):
        """Convert raw bits to floating point value."""
        sign = (bits_val >> (exp_width + man_width)) & 0x1
        exponent = (bits_val >> man_width) & ((1 << exp_width) - 1)
        mantissa = bits_val & ((1 << man_width) - 1)
        bias = (1 << (exp_width - 1)) - 1 if exp_width > 0 else 0

        if exp_width == 0:
            # No exponent: treat as int/fixed, but with optional sign
            base = float(mantissa)
        else:
            # Normal floating-point
            if exponent == 0:
                # Subnormals or zero
                if mantissa == 0:
                    return 0.0 if sign == 0 else -0.0
                base = mantissa / (2 ** man_width)
                exp_val = 1 - bias
                return ((-1) ** sign) * base * (2 ** exp_val)
            elif exponent == (1 << exp_width) - 1:
                # Inf/NaN
                if mantissa == 0:
                    return float('-inf') if sign else float('inf')
                else:
                    return float('nan')
            else:
                # Normal numbers
                base = 1 + mantissa / (2 ** man_width)
                exp_val = exponent - bias
                return ((-1) ** sign) * base * (2 ** exp_val)
        return ((-1) ** sign) * base

    with open(bin_file, "rb") as f:
        data = f.read()

    num_vals = len(data) // num_bytes_per_val
    total_rows = (num_vals + row_dim - 1) // row_dim

    for row_idx in range(total_rows):
        if row_idx < start_row_idx:
            continue
        if load_row_size is not None and row_idx >= load_row_size + start_row_idx:
            print("... (truncated)")
            break
        vals = []
        for col_idx in range(row_dim):
            val_idx = row_idx * row_dim + col_idx
            if val_idx >= num_vals:
                break
            chunk = data[val_idx * num_bytes_per_val : (val_idx + 1) * num_bytes_per_val]
            if not chunk or len(chunk) < num_bytes_per_val:
                vals.append(None)
                continue
            # Use little-endian byte order to match Rust's byte packing
            bits_val = int.from_bytes(chunk, byteorder='little')
            float_val = raw_to_fp(bits_val)
            vals.append(float_val)
        print(f"Row {row_idx:3d}: ", end="")
        for v in vals:
            if v is not None:
                print(f"{v:7.3f}", end=" ")
            else:
                print("       ", end=" ")
        print()

def view_fpsram_bin_file(bin_file,
                         start_idx=0,
                         num_elements=64,
                         row_dim=16):
    """
    Reads an FPSRAM binary file (f16/half-precision format) and prints values.

    - bin_file:       Path to the fpsram_dump.bin file
    - start_idx:      Starting element index (each element is 2 bytes for f16)
    - num_elements:   Number of elements to read
    - row_dim:        Number of values per row to group/print
    """
    import numpy as np

    with open(bin_file, "rb") as f:
        data = f.read()

    # FPSRAM is stored as f16 (half-precision float, 2 bytes per value)
    total_elements = len(data) // 2
    all_values = np.frombuffer(data, dtype=np.float16)

    end_idx = min(start_idx + num_elements, total_elements)
    values = all_values[start_idx:end_idx]

    print(f"FPSRAM values from index {start_idx} to {end_idx - 1} ({len(values)} elements):")
    for row_idx in range((len(values) + row_dim - 1) // row_dim):
        row_start = row_idx * row_dim
        row_end = min(row_start + row_dim, len(values))
        row_vals = values[row_start:row_end]
        abs_idx = start_idx + row_start
        print(f"  [{abs_idx:4d}]: ", end="")
        for v in row_vals:
            print(f"{float(v):10.4f}", end=" ")
        print()


# Example usage:
# view_bin_as_fp("hbm_for_behave_sim.bin", exp_width=4, man_width=3, num_bytes_per_val=1)
if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    vram_file = os.path.join(script_dir, "behavioral_simulator", "vram_dump.bin")
    mram_file = os.path.join(script_dir, "behavioral_simulator", "mram_dump.bin")
    golden_file = os.path.join(script_dir, "behavioral_simulator", "testbench", "build", "golden_result.txt")
    # VRAM uses BF16 format by default: sign=1, exponent=8, mantissa=7 (16 bits total = 2 bytes)

    # Load comparison params to know which rows to display
    import json
    from check_mem import compare_vram_with_golden, compare_fpsram_with_golden, print_comparison_results

    params_file = os.path.join(script_dir, "behavioral_simulator", "testbench", "build", "comparison_params.json")
    with open(params_file, "r") as f:
        params = json.load(f)

    # Check if this is an HBM test
    check_hbm = params.get("check_hbm", False)

    if check_hbm:
        # HBM checking mode
        hbm_file = os.path.join(script_dir, "behavioral_simulator", "hbm_dump.bin")
        from check_mem import compare_hbm_with_golden, print_comparison_results

        print("=" * 80)
        print("HBM Store Test Results")
        print(f"HBM location: byte {params.get('result_hbm_start_byte', 0)}, size {params.get('result_hbm_size_bytes', 0)} bytes")
        print("=" * 80)

        if os.path.exists(hbm_file):
            # For mx data type, we need to read element bytes and scales
            # Activation mx format: exp_width=4, man_width=3, element_bytes=1, block_size=8, scale_width=8
            # Scale offset = batch * hidden_size (distance from elements to scales)
            scale_offset = params.get("scale_offset", None)
            if scale_offset is None:
                # Calculate scale offset: typically batch * hidden_size for activations
                scale_offset = params.get("num_batches", 8) * params.get("elements_per_batch", 128)

            # Calculate number of elements to compare
            num_elements = params.get("num_batches", 8) * params.get("elements_per_batch", 128)

            results = compare_hbm_with_golden(
                hbm_file, golden_file,
                exp_width=4, man_width=3, element_bytes=1,
                start_byte_offset=params.get("result_hbm_start_byte", 0),
                num_elements=num_elements,
                num_batches=params.get("num_batches", 8),
                elements_per_batch=params.get("elements_per_batch", 128),
                tolerance=0.1,
                atol=0.03,
                rtol=0.1,
                scale_width=8,  # MX_SCALE_WIDTH
                block_size=8,   # BLOCK_DIM
                scale_offset=scale_offset
            )
            print_comparison_results(results, verbose=True, comparison_params=params)
        else:
            print(f"HBM dump file not found: {hbm_file}")
            print("Note: HBM content is stored but dump file is missing.")
        print("=" * 80)
        print(f"Output Results (Rows {params['start_row_idx']}-{params['start_row_idx'] + params['num_rows'] - 1})")
        print("=" * 80)
        view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=params.get("row_dim", 64), num_bytes_per_val=2,
                                start_row_idx=params["start_row_idx"],
                                load_row_size=params["num_rows"])

        print("\n" + "=" * 80)
    else:
        # Standard VRAM checking mode
        print("=" * 80)
        print(f"Output Results (Rows {params['start_row_idx']}-{params['start_row_idx'] + params['num_rows'] - 1})")
        print("=" * 80)
        view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=params.get("row_dim", 64), num_bytes_per_val=2,
                                start_row_idx=params["start_row_idx"],
                                load_row_size=params["num_rows"])

        print("\n" + "=" * 80)
        print("Comparison with Golden Output (VRAM)")
        print("=" * 80)
        results = compare_vram_with_golden(
            vram_file, golden_file,
            exp_width=8, man_width=7, num_bytes_per_val=2, row_dim=params.get("row_dim", 64),
            start_row_idx=params["start_row_idx"],
            num_batches=params["num_batches"],
            num_rows=params["num_rows"],
            elements_per_batch=params["elements_per_batch"],
            use_stride_mode=params.get("use_stride_mode", True),
            use_slice_mode=params.get("use_slice_mode", False),
            slice_per_row=params.get("slice_per_row", None)
        )
        print_comparison_results(results, verbose=True, comparison_params=params)

        # FPSRAM comparison if enabled
        if params.get("compare_fpsram", False):
            fpsram_file = os.path.join(script_dir, "behavioral_simulator", "fpsram_dump.bin")
            golden_fpsram_file = os.path.join(script_dir, "behavioral_simulator", "testbench", "build", "golden_fpsram.pt")

            if os.path.exists(fpsram_file) and os.path.exists(golden_fpsram_file):
                golden_fpsram = torch.load(golden_fpsram_file)
                fpsram_num_elements = params.get("fpsram_num_elements", 64)
                fpsram_l_start = params.get("fpsram_l_start", golden_fpsram.get("fpsram_l_start", 0))

                # Print raw FPSRAM l values
                print("\n" + "=" * 80)
                print(f"FPSRAM l values (fpsram_l_start={fpsram_l_start})")
                print("=" * 80)
                view_fpsram_bin_file(fpsram_file, start_idx=fpsram_l_start, num_elements=fpsram_num_elements, row_dim=16)

                # Print golden l values for comparison
                print("\nGolden l_new values:")
                golden_l = golden_fpsram["golden_l_new"]
                for i in range(0, len(golden_l), 16):
                    print(f"  [{i:4d}]: ", end="")
                    for j in range(min(16, len(golden_l) - i)):
                        print(f"{golden_l[i + j].item():10.4f}", end=" ")
                    print()

                # Compare exp_m_res
                print("\n" + "=" * 80)
                print("Comparison with Golden Output (FPSRAM - exp_m_res)")
                print("=" * 80)
                fpsram_m_res_start = params.get("fpsram_m_res_start", golden_fpsram.get("fpsram_m_res_start", 0))
                results_exp_m_res = compare_fpsram_with_golden(
                    fpsram_file,
                    golden_fpsram["golden_exp_m_res"],
                    start_idx=fpsram_m_res_start,
                    num_elements=fpsram_num_elements,
                    atol=0.2,
                    rtol=0.2
                )
                print_comparison_results(results_exp_m_res, verbose=True)

                # Compare l_new
                print("\n" + "=" * 80)
                print("Comparison with Golden Output (FPSRAM - l_new)")
                print("=" * 80)
                results_l_new = compare_fpsram_with_golden(
                    fpsram_file,
                    golden_fpsram["golden_l_new"],
                    start_idx=fpsram_l_start,
                    num_elements=fpsram_num_elements,
                    atol=0.2,
                    rtol=0.2
                )
                print_comparison_results(results_l_new, verbose=True)
            else:
                if not os.path.exists(fpsram_file):
                    print(f"\nFPSRAM dump file not found: {fpsram_file}")
                if not os.path.exists(golden_fpsram_file):
                    print(f"\nGolden FPSRAM file not found: {golden_fpsram_file}")


    print("Viewing MRAM dump 0 to 63 rows (BF16 format)")
    view_bin_file_by_row_fp(mram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=0, load_row_size=6)

    # print("Viewing MRAM dump 64 to 71 rows (BF16 format)")
    # view_bin_file_by_row(mram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=64, load_row_size=8)

