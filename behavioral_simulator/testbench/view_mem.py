from bitstring import BitArray
import torch
import os
import struct

def view_bin_file_by_row_int(bin_file,
                             row_dim,
                             int_width=32,
                             num_bytes_per_val=None,
                             start_row_idx=0,
                             load_row_size=None,
                             offset=0,
                             signed=True):
    """
    Reads a binary file and parses each value as an integer.

    - bin_file:         Path to the binary file
    - row_dim:          Number of values per row to group/print
    - int_width:        Bit width of the integer (default 32 for i32)
                        Common values: 8 (i8), 16 (i16), 32 (i32)
    - num_bytes_per_val:Number of bytes per value (auto-calculated from int_width if None)
    - start_row_idx:   Starting row index
    - load_row_size:    If set, limit number of rows to print
    - signed:           If True, interpret as signed integer (default True)

    Note: The Rust code uses little-endian byte order.
          If int_width is less than num_bytes_per_val * 8, the value will be masked.
    """
    # Auto-calculate bytes per value if not specified
    if num_bytes_per_val is None:
        num_bytes_per_val = (int_width + 7) // 8  # Round up to nearest byte

    # Validate that num_bytes_per_val is sufficient
    if int_width > num_bytes_per_val * 8:
        raise ValueError(f"int_width ({int_width}) exceeds num_bytes_per_val * 8 ({num_bytes_per_val * 8})")

    # Create mask for the specified bit width
    if int_width >= 64:
        mask = (1 << 64) - 1
    else:
        mask = (1 << int_width) - 1

    with open(bin_file, "rb") as f:
        data = f.read()
    num_vals = len(data) // num_bytes_per_val
    total_rows = (num_vals + row_dim - 1) // row_dim

    for row_idx in range(total_rows):
        if row_idx < start_row_idx:
            continue
        if load_row_size is not None and row_idx >= load_row_size + start_row_idx:
            print("... (truncated)")
            break
        vals = []
        for col_idx in range(row_dim):
            val_idx = row_idx * row_dim + col_idx + offset
            if val_idx >= num_vals:
                break
            chunk = data[val_idx * num_bytes_per_val : (val_idx + 1) * num_bytes_per_val]
            # print("chunk = {:?}", chunk)
            if not chunk or len(chunk) < num_bytes_per_val:
                vals.append(None)
                continue
            # Use little-endian byte order to match Rust's byte packing
            if signed:
                int_val = int.from_bytes(chunk, byteorder='little', signed=True)
            else:
                int_val = int.from_bytes(chunk, byteorder='little', signed=False)

            # Apply bit width mask
            int_val = int_val & mask

            # Sign extend if signed and the sign bit is set
            if signed and int_width < num_bytes_per_val * 8:
                sign_bit = (int_val >> (int_width - 1)) & 1
                if sign_bit == 1:
                    # Sign extend: set all upper bits to 1
                    sign_extend_mask = ((1 << (num_bytes_per_val * 8 - int_width)) - 1) << int_width
                    int_val = int_val | sign_extend_mask
                    # Convert to signed integer
                    if num_bytes_per_val == 1:
                        int_val = int_val if int_val < 128 else int_val - 256
                    elif num_bytes_per_val == 2:
                        int_val = int_val if int_val < 32768 else int_val - 65536
                    elif num_bytes_per_val == 4:
                        int_val = int_val if int_val < 2147483648 else int_val - 4294967296

            vals.append(int_val)
        print(f"Row {row_idx:3d}: ", end="")
        for v in vals:
            if v is not None:
                print(f"{v:8d}", end=" ")
            else:
                print("        ", end=" ")
        print()

def view_bin_file_by_row_fp(bin_file,
                         exp_width,
                         man_width,
                         row_dim,
                         num_bytes_per_val=2,
                         start_row_idx=0,
                         offset=0,
                         load_row_size=None):
    """
    Reads a binary file generated by Rust behavioral simulator, parses each value as custom FP.

    - bin_file:         Path to the binary file
    - exp_width:        Number of bits for exponent
    - man_width:        Number of bits for mantissa/fraction
    - row_dim:          Number of values per row to group/print
    - num_bytes_per_val:Number of bytes per value (default 2 for BF16)
    - start_row_idx:    Starting row index
    - load_row_size:    If set, limit number of rows to print

    Note: The Rust code uses bit-packing with little-endian byte order.
          For BF16 (16 bits), each value is aligned to 2 bytes.
    """
    sign_width = 1
    total_width = sign_width + exp_width + man_width
    if total_width > num_bytes_per_val * 8:
        raise ValueError("num_bytes_per_val is too small for given bit widths.")

    def raw_to_fp(bits_val):
        """Convert raw bits to floating point value."""
        sign = (bits_val >> (exp_width + man_width)) & 0x1
        exponent = (bits_val >> man_width) & ((1 << exp_width) - 1)
        mantissa = bits_val & ((1 << man_width) - 1)
        bias = (1 << (exp_width - 1)) - 1 if exp_width > 0 else 0

        if exp_width == 0:
            # No exponent: treat as int/fixed, but with optional sign
            base = float(mantissa)
        else:
            # Normal floating-point
            if exponent == 0:
                # Subnormals or zero
                if mantissa == 0:
                    return 0.0 if sign == 0 else -0.0
                base = mantissa / (2 ** man_width)
                exp_val = 1 - bias
                return ((-1) ** sign) * base * (2 ** exp_val)
            elif exponent == (1 << exp_width) - 1:
                # Inf/NaN
                if mantissa == 0:
                    return float('-inf') if sign else float('inf')
                else:
                    return float('nan')
            else:
                # Normal numbers
                base = 1 + mantissa / (2 ** man_width)
                exp_val = exponent - bias
                return ((-1) ** sign) * base * (2 ** exp_val)
        return ((-1) ** sign) * base

    with open(bin_file, "rb") as f:
        data = f.read()

    num_vals = len(data) // num_bytes_per_val
    total_rows = (num_vals + row_dim - 1) // row_dim

    for row_idx in range(total_rows):
        if row_idx < start_row_idx:
            continue
        if load_row_size is not None and row_idx >= load_row_size + start_row_idx:
            print("... (truncated)")
            break
        vals = []
        for col_idx in range(row_dim):
            val_idx = row_idx * row_dim + col_idx
            if val_idx >= num_vals:
                break
            chunk = data[val_idx * num_bytes_per_val : (val_idx + 1) * num_bytes_per_val]
            if not chunk or len(chunk) < num_bytes_per_val:
                vals.append(None)
                continue
            # Use little-endian byte order to match Rust's byte packing
            bits_val = int.from_bytes(chunk, byteorder='little')
            float_val = raw_to_fp(bits_val)
            vals.append(float_val)
        print(f"Row {row_idx:3d}: ", end="")
        for v in vals:
            if v is not None:
                print(f"{v:7.3f}", end=" ")
            else:
                print("       ", end=" ")
        print()

# Example usage:
# view_bin_as_fp("hbm_for_behave_sim.bin", exp_width=4, man_width=3, num_bytes_per_val=1)
if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    vram_file = os.path.join(script_dir, "behavioral_simulator", "vram_dump.bin")
    mram_file = os.path.join(script_dir, "behavioral_simulator", "mram_dump.bin")
    golden_file = os.path.join(script_dir, "behavioral_simulator", "testbench", "build", "golden_result.txt")
    # VRAM uses BF16 format by default: sign=1, exponent=8, mantissa=7 (16 bits total = 2 bytes)

    # Load comparison params to know which rows to display
    import json
    from check_mem import compare_with_golden, print_comparison_results

    params_file = os.path.join(script_dir, "behavioral_simulator", "testbench", "build", "comparison_params.json")
    with open(params_file, "r") as f:
        params = json.load(f)

    # Check if this is an HBM test
    check_hbm = params.get("check_hbm", False)

    if check_hbm:
        # HBM checking mode
        hbm_file = os.path.join(script_dir, "behavioral_simulator", "hbm_dump.bin")
        from check_mem import compare_hbm_with_golden, print_comparison_results

        print("=" * 80)
        print("HBM Store Test Results")
        print(f"HBM location: byte {params.get('result_hbm_start_byte', 0)}, size {params.get('result_hbm_size_bytes', 0)} bytes")
        print("=" * 80)

        if os.path.exists(hbm_file):
            # For mx data type, we need to read element bytes and scales
            # Activation mx format: exp_width=4, man_width=3, element_bytes=1, block_size=8, scale_width=8
            # Scale offset = batch * hidden_size (distance from elements to scales)
            scale_offset = params.get("scale_offset", None)
            if scale_offset is None:
                # Calculate scale offset: typically batch * hidden_size for activations
                scale_offset = params.get("num_batches", 8) * params.get("elements_per_batch", 128)

            # Calculate number of elements to compare
            num_elements = params.get("num_batches", 8) * params.get("elements_per_batch", 128)

            results = compare_hbm_with_golden(
                hbm_file, golden_file,
                exp_width=4, man_width=3, element_bytes=1,
                start_byte_offset=params.get("result_hbm_start_byte", 0),
                num_elements=num_elements,
                num_batches=params.get("num_batches", 8),
                elements_per_batch=params.get("elements_per_batch", 128),
                tolerance=0.1,
                atol=0.03,
                rtol=0.1,
                scale_width=8,  # MX_SCALE_WIDTH
                block_size=8,   # BLOCK_DIM
                scale_offset=scale_offset
            )
            print_comparison_results(results, verbose=True, comparison_params=params)
        else:
            print(f"HBM dump file not found: {hbm_file}")
            print("Note: HBM content is stored but dump file is missing.")
        print("=" * 80)
        print(f"Output Results (Rows {params['start_row_idx']}-{params['start_row_idx'] + params['num_rows'] - 1})")
        print("=" * 80)
        view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=params.get("row_dim", 64), num_bytes_per_val=2,
                                start_row_idx=params["start_row_idx"],
                                load_row_size=params["num_rows"])

        print("\n" + "=" * 80)
    else:
        # Standard VRAM checking mode
        print("=" * 80)
        print(f"Output Results (Rows {params['start_row_idx']}-{params['start_row_idx'] + params['num_rows'] - 1})")
        print("=" * 80)
        view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=params.get("row_dim", 64), num_bytes_per_val=2,
                                start_row_idx=params["start_row_idx"],
                                load_row_size=params["num_rows"])

        print("\n" + "=" * 80)
        print("Comparison with Golden Output")
        print("=" * 80)
        results = compare_with_golden(
            vram_file, golden_file,
            exp_width=8, man_width=7, num_bytes_per_val=2, row_dim=params.get("row_dim", 64),
            start_row_idx=params["start_row_idx"],
            num_batches=params["num_batches"],
            num_rows=params["num_rows"],
            tolerance = 0.1,
            elements_per_batch=params["elements_per_batch"],
            use_stride_mode=params.get("use_stride_mode", True)
        )
        print_comparison_results(results, verbose=True, comparison_params=params)

    # print("Viewing VRAM dump from 16 Base Address")
    # view_bin_file_by_row(vram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=16, load_row_size=32)

    # print("Viewing VRAM dump from 48 Base Address")
    # view_bin_file_by_row(vram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=48, load_row_size=32)

    # print("Viewing VRAM dump from 16 Base Address")
    # view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=16, load_row_size=16)

    # print("\nViewing VRAM dump from S Base Address")
    # view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=64, load_row_size=16)

    # print("\nViewing VRAM dump from PV Base Address")
    # view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=320, load_row_size=16)

    # print("\nViewing VRAM dump from O_Old Base Address")
    # view_bin_file_by_row_fp(vram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=576, load_row_size=16)

    print("Viewing MRAM dump 0 to 7 rows (BF16 format)")
    view_bin_file_by_row_fp(mram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=0, load_row_size=8)

    # print("Viewing MRAM dump 64 to 71 rows (BF16 format)")
    # view_bin_file_by_row(mram_file, exp_width=8, man_width=7, row_dim=64, num_bytes_per_val=2, start_row_idx=64, load_row_size=8)

